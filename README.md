# Random-notes
随记笔记



关于volatile关键字：
众所周知volatile 的加入保证了某个变量在内存中的“可见性”与不可“重排序”；
在单核CPU中不存在重排序的情况，重排序是由于多核CPU在并行执行时所造成的。数据执行时会刷到多个核显中，A Cpu执行时当变量在内存行中找不到时会请求请所在数据的其它CPU响应数据。A CPU在未等待到响应时，继续执行，这时就造成了指令运行时的所谓“重排序”；
为解决这个问题，抽象的引入了"内存屏障"，锁机制，其作用是：
1.强制cpu将store buffer中的内容写入到cacheline中
2.强制cpu将invalidate queue中的请求处理完毕
关于这部分内容参考：http://www.importnew.com/29860.html
volatile在保证可见性与顺序性的同时并不能保证"原子性"
参考有关CAS指令的介绍；多线程中尽量使用jdk下的原子类包数据类型；

Happen-before
JMM为了简化对编程复杂的理解，使用了HB来表达不同操作之间的可见性。HB关系在不同的书籍中有不同的表达。这里推荐一种比较好理解的。
A Happen before B,说明A操作的效果先于B操作的效果发生。这种偏序关系在单线程中是没有什么作用的，因为单线程中，执行效果要求和代码顺序一致。但是在多线程中，其可见性作用就非常明显了。举个例子，在线程1中进行进行a，b操作，操作存在hb关系。那么当线程2观察到b操作的效果时，必然也能观察到a操作的效果，因为a操作Happen before b操作。
在java中，存在HB关系的操作一共有8种，如下。

1.程序次序法则，如果A一定在B之前发生，则happen before
2.监视器法则,对一个监视器的解锁一定发生在后续对同一监视器加锁之前
3.Volatie变量法则：写volatile变量一定发生在后续对它的读之前
4.线程启动法则：Thread.start一定发生在线程中的动作前
5.线程终结法则：线程中的任何动作一定发生在线程终结之前（其他线程检测到这个线程已经终止，从Thread.join调用成功返回，Thread.isAlive()返回false）
6.中断法则：一个线程调用另一个线程的interrupt一定发生在另一线程发现中断之前。
7.终结法则：一个对象的构造函数结束一定发生在对象的finalizer之前
8.传递性：A发生在B之前，B发生在C之前，A一定发生在C之前。

关于CPU缓存一致性协议MESI
M      E      S    I


E				   *


S             *    *


I	   *	  *    *
